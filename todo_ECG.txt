################################################################################
    DONE
################################################################################

/* I CHANGED THIS!
    - Create a directory for the metric in 
        /Src/physics/RHD/Schwarzschild-ECG
    - Add this option in the Makefile
        /Src/physics/RHD/Makefile
    I did this as 
        ifeq ($(METRIC),Schwarzschild-ECG)
            PARAM += -DMETRIC=SCHW_ECG
        endif
    - Created a new value for the macro METRIC, SCHW_ECG = 6, in the file
        /Src/include/macros
    I modified also the file 
        /Src/common/messages.c
    to print messages for the ECG metric.
*/

- Create a new simulation in 
    /SIMULATIONS/RHD/Wind-Schwarzschild-ECG
    - In the Makefile of the simulation, choose the metric and the coordinates (spherical)
- Find where the macro METRIC is checked in the code, and make it work for the ECG metric.
    - It is checked only in the Makefile 
        /Src/physics/RHD/Makefile
      This simply tells the compiler to compile the correct metric.c

- Define the metric of ECG in 
    /SIMULATIONS/RHD/Wind-Schwarzschild-ECG/user_metric.c
    - In order to free the resources of the metric at the end:
        - I defined a function Free_Interpolated_Metric() in user_param.h and user_metric.c, 
          in the directory of the simulation.
          I also defined a preprocessor macro.
          When this macro is defined, the function Free_Interpolated_Metric() is
          called at the end of the main() function, in main.c.

- Compute the mass accretion rate
    - This is done in the file, inside the simulation folder:
        accretion_rate.c
    - I modified the way that it is computed, removing some constants.
        - I removed some multiplicative constants that I think should not be there,
          when updating the variable Mdot.

- Plotting
    - For plotting the velocities (only for DIM=2)
        - I changed the script plot_2D.py in the Wind-Schwarzschild-ECG directory so 
          that the quiver and stream plots are symmetric.
        - I modified the file (only for DIM=2)
            Src/common/output.c
          so it also outputs to the file sqrt(f(r)) at each position in the space.
          This allows me to plot the velocities accurately with the script
            Graphics/plot_2D.py
          which I also modified, so it multiplies the radial component of the velocity
          by this sqrt(f(r)).
          I also had to modify (only for DIM=2)
            Src/common/restart.c
          such that it ignores the last element in each line when it reads the output file.
        - In order to plot the velocities:
            - In the output of the C code, write also the value of f(r) at each point. 
              This is used to scale the radial velocity when plotting it in the Python script.

- Bash script to run several simulations in a row.
    - This is the script 
        run_simulations.sh
    - Compile Aztekas for the different values of v_inf
      I placed these in ./aztekas_binaries
    - Different .param files for the simulations
      I placed these in ./paramfiles_ECG



################################################################################
    IMPROVEMENTS TO DO
################################################################################

- Option for the interpolating polynomials to be of higher order.
  I should change the functions for f(r) and f(r), but also Read_Interpolation_f_Metric.

- Define the metric of ECG in
    /Src/physics/RHD/Schwarzschild-ECG
  so it can be used by other simulations.

- Since the metric does not change in time, I could compute it only once at the beginning.
  This would require modifying the structure of the code.
    - Define another preprocessor macro, as a flag for this
    - This is not easy, with the current state of the code, as the structs gauge_
      and der_gauge_ only hold the values for one single point in the space. Therefore,
      I would need to define an array of the (one per point in the grid), compute
      all of them in the beginning and read them when required.
    - Another possibility is to compute these arrays of gauge_ and der_gauge_ at the
      beginning, when the metric is loaded.
      Then, the functions Get_Metric_Components and Gauge_Derivatives would just
      look up the values and return them, without need to compute.
      I THINK THIS IS THE BEST CHOICE

################################################################################
    TO DO
################################################################################

- .param files for different values of epsilon:
    5
    20
    500
    (and maybe more)
  In each case, x1min (the minimum value of the coordinate r) should change with 
  the horizon radius, as 2.5 r_h
    - Do this for different values of v_inf in each case
        v_inf = 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9
    - Do this for different values of the adiabatic index
        K = 4/3 (1.33), 5/3 (1.66) (as in the paper)
        - I only do it for K = 4/3
    - Do this only for a value of the Mach number:
        M = 5
- Compute the compression ratio.




################################################################################
    NOTES ON THE CODE
################################################################################

- The mesh has values of the coordinates in the system given (not always cartesian).
If the coordinate system is SPHERICAL, the coordinate x2 is multiplied by PI, and if
it is CYLINDRICAL or SPHERICAL the coordinate x3 is multiplied by PI.
    This happens in the function Default_Parameters, in the file 
        Src/common/input.c
- The parameter gc (number of ghost cells) is defined as a preprocessor macro in
    Src/Makefile
- Output file:
    - The first few lines are information on the domain and time of the current frame
    - The following columns are the values in the grid of:
        DIM = 2: x1, x2, density, pressure (?), v_x, v_y

- In order to generate the plots and video, I copy the scripts frames and video_maker 
  in the directory where the output files are placed.


################################################################################
    QUESTIONS ABOUT THE CODE
################################################################################

- In plot_2D.py:
    - In the spherical and cylindrical case, I think the labels are not correct,
    since the meshgrid is cartesian (although the original coordinates are angular and radial).

- How do I compute the compression ratio?

- Where does the horizon radius enter the computations?


################################################################################
    NOTES ON COMPILATION AND EXECUTION
################################################################################

- Run `bear -- make` inside the simulation folder to create the compile_commands.json
file, so the coc.nvim plugin knows where to find the definitions of the different functions.

