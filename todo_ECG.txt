################################################################################
    DONE
################################################################################

/* I CHANGED THIS!
    - Create a directory for the metric in 
        /Src/physics/RHD/Schwarzschild-ECG
    - Add this option in the Makefile
        /Src/physics/RHD/Makefile
    I did this as 
        ifeq ($(METRIC),Schwarzschild-ECG)
            PARAM += -DMETRIC=SCHW_ECG
        endif
    - Created a new value for the macro METRIC, SCHW_ECG = 6, in the file
        /Src/include/macros
    I modified also the file 
        /Src/common/messages.c
    to print messages for the ECG metric.
*/

- Create a new simulation in 
    /SIMULATIONS/RHD/Wind-Schwarzschild-ECG
    - In the Makefile of the simulation, choose the metric and the coordinates (spherical)
- Find where the macro METRIC is checked in the code, and make it work for the ECG metric.
    - It is checked only in the Makefile 
        /Src/physics/RHD/Makefile
      This simply tells the compiler to compile the correct metric.c

- Define the metric of ECG in 
    /SIMULATIONS/RHD/Wind-Schwarzschild-ECG/user_metric.c
    - In order to free the resources of the metric at the end:
        - I defined a function Free_Interpolated_Metric() in user_param.h and user_metric.c, 
          in the directory of the simulation.
          I also defined a preprocessor macro.
          When this macro is defined, the function Free_Interpolated_Metric() is
          called at the end of the main() function, in main.c.
    - In order to make the computations faster, I evaluate at the beginning the function f(r)
      and its derivative at each point in the grid. Then, when calling Get_Metric_Components and
      Gauge_Derivatives these values are retrieved.
        - When doing this, each time the variable gauge_ local_grid is defined I had
          to set also the index of the point in the radial direction.
            ./Src/fluxes/sources.c
            ./Src/fluxes/fluxes.c
            ./Src/common/output.c
            ./Src/physics/RHD/.q2uvector.c
            ./Src/physics/RHD/surface_volume.c
            ./Src/physics/RHD/HYDRO/stiff_q2uvector.c
            ./Src/physics/RHD/HYDRO/surface_volume.c
            ./Src/physics/RHD/HYDRO/prim2cons.c
            ./Src/physics/RHD/HYDRO/new_q2uvector.c
            ./Src/physics/RHD/HYDRO/cons2prim.c
            ./SIMULATIONS/RHD/Wind-Schwarzschild-ECG/accretion_rate.c
            ./SIMULATIONS/RHD/Wind-Schwarzschild-ECG/initial.c
            ./SIMULATIONS/RHD/Wind-Schwarzschild-ECG/user_boundaries.c
          I did this also where Gauge_Derivatives is called
            ./Src/physics/RHD/HYDRO/sources.c
          This index goes from 0 to Nx1
        - Write a check when retrieving the value of the metric at the point to see
          if the index of the radius is correct.
        - I had to move the call to Surface_Volume in Mesh() to the end of Init_Simulation(),
          so it is run after the metric has been loaded and computed.
        - The values of f(r) and f'(r) are computed at the beginning, in the function 
          Compute_f_In_Grid() that I defined in the source files of the simulation.

- Compute the mass accretion rate
    - This is done in the file, inside the simulation folder:
        accretion_rate.c
    - I modified the way that it is computed, removing some constants.
        - I removed some multiplicative constants that I think should not be there,
          when updating the variable Mdot.

- Plotting
    - For plotting the velocities (only for DIM=2)
        - I changed the script plot_2D.py in the Wind-Schwarzschild-ECG directory so 
          that the quiver and stream plots are symmetric.
        - I modified the file (only for DIM=2)
            Src/common/output.c
          so it also outputs to the file sqrt(f(r)) at each position in the space.
          This allows me to plot the velocities accurately with the script
            Graphics/plot_2D.py
          which I also modified, so it multiplies the radial component of the velocity
          by this sqrt(f(r)).
          I also had to modify (only for DIM=2)
            Src/common/restart.c
          such that it ignores the last element in each line when it reads the output file.
        - In order to plot the velocities:
            - In the output of the C code, write also the value of f(r) at each point. 
              This is used to scale the radial velocity when plotting it in the Python script.

- Bash script to run several simulations in a row.
    - This is the script 
        run_simulations.sh
    - Compile Aztekas for the different values of v_inf
      I placed these in ./aztekas_binaries
    - Different .param files for the simulations
      I placed these in ./paramfiles_ECG



################################################################################
    IMPROVEMENTS TO DO
################################################################################

- Option for the interpolating polynomials to be of higher order.
  I should change the functions for f(r) and f(r), but also Read_Interpolation_f_Metric.

- Define the metric of ECG in
    /Src/physics/RHD/Schwarzschild-ECG
  so it can be used by other simulations.

- Since the metric does not change in time, I could compute it only once at the beginning.
  This would require modifying the structure of the code.
    - Define another preprocessor macro, as a flag for this
    - This is not easy, with the current state of the code, as the structs gauge_
      and der_gauge_ only hold the values for one single point in the space. Therefore,
      I would need to define an array of the (one per point in the grid), compute
      all of them in the beginning and read them when required.
    - Another possibility is to compute these arrays of gauge_ and der_gauge_ at the
      beginning, when the metric is loaded.
      Then, the functions Get_Metric_Components and Gauge_Derivatives would just
      look up the values and return them, without need to compute.
      I THINK THIS IS THE BEST CHOICE

################################################################################
    TO DO
################################################################################

- .param files for different values of epsilon:
    5
    20
    500
    (and maybe more)
  In each case, x1min (the minimum value of the coordinate r) should change with 
  the horizon radius, as 2.5 r_h
    - Do this for different values of v_inf in each case
        v_inf = 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9
    - Do this for different values of the adiabatic index
        K = 4/3 (1.33), 5/3 (1.66) (as in the paper)
        - I only do it for K = 4/3
    - Do this only for a value of the Mach number:
        M = 5
- Compute the compression ratio.
    - Emilio should tell me how to do this
    - Take the density at infinity and at some reference value of the radius (proportional
      to the horizon radius).

- Improve the computations
    - Try to reduce the minimum radius
        - Study the stability of the system. 
          Does the accretion rate change much when this minimum radius is modified?
    - Once the computation works in ECG, increase the resolution

- Computations in Kerr-Schild coordinates
    - It works in GR, with v_inf = 0.5 and r_min = 1.5, with a grid of 200x200
        - The result is Mdot / Mdot_BHL = 3.20
        - Try with r_min = r_horizon
    - Do this with the cubic corrections
        - I must find the correct form of the metric in terms of f(r).
            - In order to convert the metric to coordinates that are regular at the horizon,
              use the change of coordinates in page 235 of my notes.
        - Solve f(r) inside the horizon too.

- Values of Mdot / Mdot_BHL (ballistic / spherical coords / Kerr-Schild coords)
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    | epsilon \ v_inf | 0.2                     | 0.3                     | 0.5                     | 0.7                     | 0.8                     | 0.9                     |
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    | 0               | 1.33026 / XXXXX / 0.947?| XXXXXXX / XXXXX / XXXXX | 3.26888 / 2.745 / 2.6.. | XXXXXXX / XXXXX / 5.689 | XXXXXXX / XXXXX / XXXXX | 15.4367 / XXXXX / XXXXX |
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    | 5               | 1.33041 / 0.762 / 1.260?| XXXXXXX / XXXXX / XXXXX | 3.57748 / 3.236 / 3.671 | XXXXXXX / XXXXX / 9.363 | XXXXXXX / XXXXX / XXXXX | 30.1309 / XXXXX / XXXXX |
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    | 20              | 1.33075 / 0.911 / XXXXX | XXXXXXX / XXXXX / XXXXX | 4.80481 / 4.598 / 5.226 | XXXXXXX / XXXXX / 14.07 | XXXXXXX / XXXXX / XXXXX | 47.7397 / XXXXX / XXXXX |
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    | 500             | 1.34168 / 1.093 / XXXXX | XXXXXXX / XXXXX / XXXXX | 14.7610 / 14.02 / 15.72 | XXXXXXX / XXXXX / 46.75 | XXXXXXX / XXXXX / XXXXX | 171.291 / XXXXX / XXXXX |
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

- Values of log( Mdot / Mdot_0 ) (ballistic / spherical coords / Kerr-Schild coords)
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    | epsilon \ v_inf | 0.2                     | 0.3                     | 0.5                     | 0.7                     | 0.8                     | 0.9                     |
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    | 0               | 2.21694 / XXXXX / 2.073?| XXXXXXX / XXXXX / XXXXX | 1.41749 / 1.342 / 1.368 | XXXXXXX / XXXXX / 1.220 | XXXXXXX / XXXXX / XXXXX | 1.32699 / XXXXX / XXXXX |
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    | 5               | 2.21699 / 1.979 / 2.197?| XXXXXXX / XXXXX / XXXXX | 1.45667 / 1.413 / 1.468 | XXXXXXX / XXXXX / 1.436 | XXXXXXX / XXXXX / XXXXX | 1.61744 / XXXXX / XXXXX |
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    | 20              | 2.21710 / 2.057 / XXXXX | XXXXXXX / XXXXX / XXXXX | 1.58477 / 1.566 / 1.621 | XXXXXXX / XXXXX / 1.613 | XXXXXXX / XXXXX / XXXXX | 1.81731 / XXXXX / XXXXX |
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    | 500             | 2.22066 / 2.135 / XXXXX | XXXXXXX / XXXXX / XXXXX | 2.07221 / 2.050 / 2.100 | XXXXXXX / XXXXX / 2.134 | XXXXXXX / XXXXX / XXXXX | 2.37216 / XXXXX / XXXXX |
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


- Next steps
    - Run the comptuation in spherical coordinates for epsilon = 0 up to a larger value of time
    - Plot the results with the curves from ballistic accretion
    - Calculations in Kerr-Schild coordinates with ECG corrections
        - Implement the metric
            - Implement evaluation of the functions at the horizon
        - Create the paramfiles
        - Run the simulation
    - Check the precision of the coefficients of the polynomials in Mathematica
        - Export them in binary format?
    - Take r_min and r_max as in their paper, in terms of r_acc
    - The time until stabilization also depends on v_inf.

    - Pending computations:
      v = 0.2
        eps = 0   -> Improve
        eps = 5   -> Improve
        eps = 20  -> Improve
        eps = 500 -> Not convergent
      v = 0.3
        eps = 0   -> Improve
        eps = 5   -> Improve
        eps = 20  -> Improve
        eps = 500 -> Not convergent
      v = 0.4
        eps = 0
        eps = 5
        eps = 20
        eps = 500
      v = 0.5
        eps = 0 -> Improve
      v = 0.6
        eps = 5
        eps = 20
        eps = 500
      v = 0.8
        eps = 0
        eps = 5
        eps = 20
        eps = 500
      v = 0.9
        eps = 0
        eps = 5
        eps = 20
        eps = 500




################################################################################
    NOTES ON THE CODE
################################################################################

- The mesh has values of the coordinates in the system given (not always cartesian).
If the coordinate system is SPHERICAL, the coordinate x2 is multiplied by PI, and if
it is CYLINDRICAL or SPHERICAL the coordinate x3 is multiplied by PI.
    This happens in the function Default_Parameters, in the file 
        Src/common/input.c
- The parameter gc (number of ghost cells) is defined as a preprocessor macro in
    Src/Makefile
- Output file:

    - The first few lines are information on the domain and time of the current frame
    - The following columns are the values in the grid of:
        DIM = 2: x1, x2, density, pressure (?), v_x, v_y

- In order to generate the plots and video, I copy the scripts frames and video_maker 
  in the directory where the output files are placed.


################################################################################
    QUESTIONS ABOUT THE CODE
################################################################################

- In plot_2D.py:
    - In the spherical and cylindrical case, I think the labels are not correct,
    since the meshgrid is cartesian (although the original coordinates are angular and radial).

- How do I compute the compression ratio?

- Do I have to multiply or divide the mass accretion rate by something (e.g. the lapse function)
  to obtain the same results as the paper?


################################################################################
    NOTES ON COMPILATION AND EXECUTION
################################################################################

- Run `bear -- make` inside the simulation folder to create the compile_commands.json
file, so the coc.nvim plugin knows where to find the definitions of the different functions.

